/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: /home/titan/wp/fusion_dds/idl/PointCloud2.idl
  Source: PointCloud2.cpp
  Cyclone DDS: v0.11.0

*****************************************************************/
#include "PointCloud2.hpp"

namespace org{
namespace eclipse{
namespace cyclonedds{
namespace core{
namespace cdr{

template<>
const propvec &get_type_props<::lidar_msgs::msg::PointXYZIRT>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int16_t>(), extensibility::ext_final, false));  //::x
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<int16_t>(), extensibility::ext_final, false));  //::y
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<int8_t>(), extensibility::ext_final, false));  //::z
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::intensity

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::lidar_msgs::msg::PointCloud2>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::height
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::width
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::is_dense
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::timestamp
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::seq
  props.push_back(entity_properties_t(1, 5, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::frame_id
  props.push_back(entity_properties_t(1, 6, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::points
  entity_properties_t::append_struct_contents(props, get_type_props<::lidar_msgs::msg::PointXYZIRT>());  //internal contents of ::points

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

} //namespace cdr
} //namespace core
} //namespace cyclonedds
} //namespace eclipse
} //namespace org

